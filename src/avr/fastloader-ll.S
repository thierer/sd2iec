/* sd2iec - SD/MMC to Commodore serial bus interface/controller
   Copyright (C) 2007-2022  Ingo Korb <ingo@akana.de>
   Copyright (C) 2007-2008  M.Kiesel <mayne@users.sourceforge.net>
   Final Cartridge III, DreamLoad fastloader support:
   Copyright (C) 2008  Thomas Giesel <skoe@directbox.com>

   Inspired by MMC2IEC by Lars Pontoppidan et al.

   FAT filesystem access based on code from ChaN, see tff.c|h.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; version 2 of the License only.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


   fastloader.S: Low level fastloader transfer routines.

   Thanks to Jochen Adler for his Jiffy docs at http://www.nlq.de/

*/


#include "asmconfig.h"
#include "fastloader.h"
#include <avr/io.h>

#ifndef CONFIG_MCU_FREQ
#  error "CONFIG_MCU_FREQ must be defined for delay cycle calculation."
#endif

/* Timing offsets for JiffyDos read/write (3.75 us) */
/* These values are added to the delayloop counter before the first      */
/* bitpair read/write. They were determined experimentally to center the */
/* range of working OSCCAL values around the default value.              */
#define JIFFY_OFFSET_WRITE (375*CONFIG_MCU_FREQ/100000000)
#define JIFFY_OFFSET_READ  (375*CONFIG_MCU_FREQ/100000000)

        .section .text

#if defined(IEC_ATN_INT_VECT) && defined(CONFIG_LOADER_DREAMLOAD)
        ;; ===================================================================
        ;; ATN(+CLK) Interrupt service routine for IEC bus
        ;; ===================================================================
        ;
        ; Functions called from here may change the r18 register
        ; Other registers must be saved and restored by the called functions
        ;
        .global IEC_ATN_INT_VECT
IEC_ATN_INT_VECT:
        push    r18
        in      r18, _SFR_IO_ADDR(SREG)
        push    r18

#ifdef IEC_PCMSK
        lds     r18, _SFR_ADDR(IEC_PCMSK)
        bst     r18, IEC_PIN_ATN        ; only check ATN
        brtc    iiv_atn_irq_end         ; if it is an IRQ source
#endif

        ; check if ATN is low
        sbic    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_ATN
        rjmp    iiv_atn_irq_end

        ; ATN is low, set DATA to ACK
        sbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA

        ; continue depending from active fast loader
        lds     r18, detected_loader
        cpi     r18, FLCODE_DREAMLOAD_OLD
        brne    iiv_atn_irq_end         ; not dreamload_old

        ; dreamload (old), receive a command code
        rcall   dreamload_get_command_old

iiv_atn_irq_end:
#ifdef IEC_PCMSK
        lds     r18, _SFR_ADDR(IEC_PCMSK)
        bst     r18, IEC_PIN_CLOCK      ; only check CLOCK
        brtc    iiv_clock_irq_end       ; if it is an IRQ source

        ; check if CLOCK is low
        sbic    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK
        rjmp    iiv_clock_irq_end

        ; CLOCK is low, continue depending from active fast loader
        lds     r18, detected_loader
        cpi     r18, FLCODE_DREAMLOAD
        brne    iiv_not_fl_dreamload
        ; dreamload, receive a command code
        rcall   dreamload_get_command

iiv_not_fl_dreamload:
#endif // ifdef IEC_PCMSK

iiv_clock_irq_end:

        pop     r18
        out     _SFR_IO_ADDR(SREG), r18
        pop     r18
        reti
#endif // ifdef IEC_ATN_INT_VECT


#ifdef IEC_CLK_INT_VECT
        ;; ===================================================================
        ;; CLK Interrupt service routine for IEC bus
        ;; ===================================================================
        ;
        ; Functions called from here may change the r18 register
        ; Other registers must be saved and restored by the called functions
        ;
        .global IEC_CLK_INT_VECT
IEC_CLK_INT_VECT:
        ; bail early if CLOCK isn't low
        sbic    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK
        reti

        push    r18
        in      r18, _SFR_IO_ADDR(SREG)
        push    r18

        ; continue depending from active fast loader
#ifdef CONFIG_LOADER_DREAMLOAD
        lds     r18, detected_loader
        cpi     r18, FLCODE_DREAMLOAD
        brne    clk_not_fl_dreamload
        ; dreamload, receive a command code
        rcall   dreamload_get_command
clk_not_fl_dreamload:
#endif // ifdef CONFIG_LOADER_DREAMLOAD

clk_irq_end:

        pop     r18
        out     _SFR_IO_ADDR(SREG), r18
        pop     r18
        reti
#endif // ifdef IEC_CLK_INT_VECT


        ;; ===================================================================
        ;;  Utility routines
        ;; ===================================================================

        ; RCALL and RET each take an additional cycle on MCUs with >128kB
        ; program memory (and therefore a 22 bit PC).
        ; These are defined as offset to the (16 bit PC) base value instead of
        ; absolute cycles because that simplifies delay cycle calculation.
#ifndef __AVR_3_BYTE_PC__
#  define RCALL_OFFSET  0
#  define RET_OFFSET    0
#else
#  define RCALL_OFFSET  1
#  define RET_OFFSET    1
#endif

        ;;  Used by the macros below, don't call directly
        nop
        nop
delay_loop:
        dec     r18             ; 1 (ldi) + 3*#r18 - 1 (last brne not taken)
        brne    delay_loop
delay_7:                        ; 3+4=7 (16 bit PC) / 4+5=9 (22 bit PC)
        ret

        ;; This macro waits for the specified number of cycles
        ;;  Uses r18
        .macro delay_cycles num
        .if     \num >= 10 + RCALL_OFFSET + RET_OFFSET
        ldi     r18, (\num - (7 + RCALL_OFFSET + RET_OFFSET)) / 3
        rcall   delay_loop - 2*((\num - (10 + RCALL_OFFSET + RET_OFFSET)) % 3)
        .elseif \num >= 7 + RCALL_OFFSET + RET_OFFSET
        rcall   delay_7
        delay_cycles \num - (7 + RCALL_OFFSET + RET_OFFSET)
        .elseif \num >= 2
        rjmp    .+0
        delay_cycles \num-2
        .elseif \num == 1
        nop
        .endif
        .endm


        ;; Delay in 0.5us resolution. Only used if the additional resolution is
        ;; necessary, most places use delay_us below (which calls this macro).
        ;;
        ;; offset is the number of cycles to add to the result of the
        ;; conversion from [us]. Can be either positive or negative, but a
        ;; negative value can result in an illegal (ie negative) delay.
        .macro  delay_05us us05:req, offset=0
        .if ((\us05)*CONFIG_MCU_FREQ%(2*1000000)         != 0) || \
            ((\us05)*CONFIG_MCU_FREQ/(2*1000000)+\offset <  0)
        .error "Invalid delay value and/or CONFIG_MCU_FREQ"
        .endif
        delay_cycles (\us05) * CONFIG_MCU_FREQ/(2*1000000) + \offset
        .endm

        ;; Delay in 1us resolution.
        .macro  delay_us us:req, offset=0
        delay_05us 2*(\us), \offset
        .endm

        ;; wait for ATN high
wait_atn_high:
        sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_ATN
        rjmp    wait_atn_high
        ret

        ;; wait for ATN low
wait_atn_low:
        sbic    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_ATN
        rjmp    wait_atn_low
        ret


        ;; ====================================================================
        ;;  JiffyDOS
        ;; ====================================================================

        ;;
        ;; Receives a single byte using the JiffyDOS protocol
        ;; return uint8_t reveicedbyte (r24)
        ;;
        .global jiffy_receive
jiffy_receive:
        ;; Disable interrupts
        cli

        ;; Move pointer to EOF variable into Z
        movw    r30,r24
        clr     r24             ; clear output register
        clr     r25             ; clear high byte of return value

        ;; Set clock+data high
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_CLOCK
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA

        ;; Wait until clock is high and emulate ATN-Ack
0:      sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_ATN
        sbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA ; Data low if ATN is low
        sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK
        rjmp    0b

        ;; Wait for 13us from clock high
        delay_us 13, JIFFY_OFFSET_READ

        ;; Read bit 5+4
        in      r0, _SFR_IO_ADDR(IEC_INPUT) ; 1

        ;; Store bits in r24
        bst     r0, IEC_PIN_DATA  ; 1 - get data bit
        bld     r24, 5            ; 1 - store as bit 5
        bst     r0, IEC_PIN_CLOCK ; 1 - get clock bit
        bld     r24, 4            ; 1 - store as bit 4

        ;; Wait 13us
        delay_us 13, -5

        ;; Read bit 7+6
        in      r0, _SFR_IO_ADDR(IEC_INPUT) ; 1

        ;; Store bits in r24
        bst     r0, IEC_PIN_DATA  ; 1 - get data bit
        bld     r24, 7            ; 1 - store as bit 7
        bst     r0, IEC_PIN_CLOCK ; 1 - get clock bit
        bld     r24, 6            ; 1 - store as bit 6

        ;; Wait 11us
        delay_us 11, -5

        ;; Read bit 1+3 [sic]
        in      r0, _SFR_IO_ADDR(IEC_INPUT) ; 1
        bst     r0, IEC_PIN_DATA  ; 1 - get data bit
        bld     r24, 1            ; 1 - store as bit 1
        bst     r0, IEC_PIN_CLOCK ; 1 - get clock bit
        bld     r24, 3            ; 1 - store as bit 3

        ;; Wait 13us
        delay_us 13, -5

        ;; Read Bit 0+2
        in      r0, _SFR_IO_ADDR(IEC_INPUT) ; 1
        bst     r0, IEC_PIN_DATA  ; 1 - get data bit
        bld     r24, 0            ; 1 - store as bit 0
        bst     r0, IEC_PIN_CLOCK ; 1 - get clock bit
        bld     r24, 2            ; 1 - store as bit 2

        ;; Wait 13us
        delay_us 13, -5

        ;; Read EOI mark
        in      r19, _SFR_IO_ADDR(IEC_INPUT) ; 1

        ;; Wait 6us
        delay_us 6, -1

        ;; Data low
        sbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA ; 1
        delay_us 10             ; make sure the C64 can see that

        ;; Post-process data and store last bus state
        com     r24             ; invert received data (result)
        st      Z, r19          ; store last bus state
        sei                     ; enable interrupts
        ret



        ;; Shifts the lowest two bits from r0 to r19
        ;; and sends then on the bus at cycle 12 (or 13 for 22 bit PC MCUs)
        ;; Needs 16 (or 18) cycles including the rcall
jiffy_sendbits:
        in      r19, _SFR_IO_ADDR(IEC_OUTPUT) ; 1 - read port
        andi    r19, ~(IEC_OBIT_DATA|IEC_OBIT_CLOCK|IEC_OBIT_ATN|IEC_OBIT_SRQ)
                                    ; 1 - mask IEC bits
        bst     r0, 0               ; 1 - get bit 0
        bld     r19, IEC_OPIN_CLOCK ; 1 - send on the clock line
        bst     r0, 1               ; 1 - get bit 1
        bld     r19, IEC_OPIN_DATA  ; 1 - send on the data line
        lsr     r0                  ; 1 - remove source bits
        lsr     r0                  ; 1
        out     _SFR_IO_ADDR(IEC_OUTPUT), r19 ; 1 - output the bit pair
        ret                         ; 4 or 5

        ;;
        ;; Sends a single byte using the Jiffy protocol
        ;; uint8_t value (r24), uint8_t eoi (r22), uint8_t loadflags (r20)
        ;; return uint8_t atnactive (r24)
        ;;
        ;; eoi should always be 0 for LOAD because the eoi marker is
        ;; transmitted in a different way there (see C code).
        ;;
        ;; Loadflags has a dual purpose:
        ;;  - if it's != 0, the start condition will be modified for Jiffy-LOAD
        ;;  - bit 7 will be cleared after that
        ;;  - if it's still != 0, the function will exit after sending
        ;;    the last bitpair - required for all but the final byte of a block
        ;;    during LOAD
        .global jiffy_send
jiffy_send:
        cli                     ; Disable interrupts

        ;; Calculate bus wait condition based on current state
        ;; The loop below will spin while ATN and Clock are high and
        ;; - Data is low  (single-byte transfer)
        ;; - Data is high (LOAD)
        ldi     r21, IEC_BIT_CLOCK | IEC_BIT_ATN
        tst     r20             ; loadflag set?
        breq    0f              ; Yes, skip
                ; No: Set data bit
        ori     r21, IEC_BIT_DATA

0:      andi    r20, 0x7f       ; Clear bit 7 of loadflags

        ;; Calculate bus state for EOI/not-EOI mark
        tst     r22             ; EOI flag set?
        breq    0f              ; No, branch

        in      r22, _SFR_IO_ADDR(IEC_OUTPUT)
        andi    r22, ~(IEC_OBIT_DATA|IEC_OBIT_CLOCK|IEC_OBIT_ATN|IEC_OBIT_SRQ)
        ori     r22, IEC_OBIT_DATA ; Data low, Clock hi on EOI
        rjmp    1f

0:      in      r22, _SFR_IO_ADDR(IEC_OUTPUT)
        andi    r22, ~(IEC_OBIT_DATA|IEC_OBIT_CLOCK|IEC_OBIT_ATN|IEC_OBIT_SRQ)
        ori     r22, IEC_OBIT_CLOCK ; Data hi, Clock low on non-EOI

1:
        ;; Set clock and data high/inactive - FFB5
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA
                ; this is the actual ready signal for the C64
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_CLOCK

        ;; Wait 1us to allow the bus to settle (J1541 needs 4us here)
        delay_us 1

        ;; Set up a few registers
        mov     r0, r24         ; move data byte to r0
        com     r0              ; invert data byte

        ;; Wait for start condition (calculated above) from C64 - FFB8
0:      in      r24, _SFR_IO_ADDR(IEC_INPUT)
        andi    r24, IEC_BIT_CLOCK | IEC_BIT_DATA | IEC_BIT_ATN ; 1
        cp      r24, r21        ; 1
        breq    0b              ; 1

        ;; Check for ATN (J1541 doesn't do this, but I'm paranoid)
        ;; Doesn't work, further analysis required
        andi    r24, IEC_BIT_ATN ; 1
        breq    js_finish        ; 1 - jump if ATN is low

        ;; Output the first bitpair 6us after the start
        ;; 6us is the best-case time from bus check to transmission in J1541
        delay_us 6, JIFFY_OFFSET_WRITE-5-12-RCALL_OFFSET
        rcall   jiffy_sendbits  ; 12+4 or 13+5 - [FFBD]

        ;; Output the second bitpair 10us after the first
        delay_us 10, -16-RET_OFFSET-RCALL_OFFSET

        rcall   jiffy_sendbits  ; 12+4 or 13+5 - [FFC4]

        ;; Output the third bitpair 11us after the second
        delay_us 11, -16-RET_OFFSET-RCALL_OFFSET

        rcall   jiffy_sendbits  ; 12+4 or 13+5 - [FFCC]

        ;; Output the fourth bitpair 10us after the third
        delay_us 10, -16-RET_OFFSET-RCALL_OFFSET

        rcall   jiffy_sendbits  ; 12+4 or 13+5 - [FFD3]

        delay_us 6              ; 6us hold time

        ;; Skip sending EOI for LOAD code path
        tst     r20             ; 1
        brne    js_finish       ; 1

        ;; Output EOI marker 11us after the last bitpair
        delay_us 5, -7-RET_OFFSET

        out     _SFR_IO_ADDR(IEC_OUTPUT), r22 ; 1 - output EOI marker [FFDB]

        ;; Wait 1us to allow the bus to settle (J1541 needs 4us here)
        delay_us 1

        ;; Wait until data is low, check ATN [FFDE]
        ;; This loop won't wait when EOI is signalled.
0:      in      r24, _SFR_IO_ADDR(IEC_INPUT) ; Read bus
        sbrs    r24, IEC_PIN_ATN           ; Skip if ATN is high
        rjmp    js_finish                  ; ATN low, exit loop
        sbrc    r24, IEC_PIN_DATA          ; Skip if Data is low
        rjmp    0b                         ; No Data, no ATN -> loop

js_finish:
        com     r24             ; invert port state (ATN low returns true)
        andi    r24, IEC_BIT_ATN ; single out ATN bit

        sei                     ; re-enable interrupts
        ret


#ifdef CONFIG_LOADER_TURBODISK
        ;; ====================================================================
        ;;  Turbodisk
        ;; ====================================================================

        ;;
        ;; Sends a single byte in r24 using the Turbodisk protocol
        ;;
        .global turbodisk_byte
turbodisk_byte:
        ;; Wait until data is low
        sbic    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_DATA
        rjmp    turbodisk_byte

        ;; Byte preparation
        com     r24             ; Invert the data byte

        ;; All bus lines high
        in      r18, _SFR_IO_ADDR(IEC_OUTPUT)
        andi    r18, ~(IEC_OBIT_DATA|IEC_OBIT_CLOCK|IEC_OBIT_ATN|IEC_OBIT_SRQ)
        out     _SFR_IO_ADDR(IEC_OUTPUT), r18

        ;; Wait until data is high
0:      sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_DATA ; 2
        rjmp    0b

        delay_us 1              ; Move the timing window slightly

        ldi     r20, 4          ; 1 - Bitpair counter

tdbitloop:
        in      r19, _SFR_IO_ADDR(IEC_OUTPUT) ; 1 - read & mask unused IEC port lines
        andi    r19, ~(IEC_OBIT_DATA|IEC_OBIT_CLOCK|IEC_OBIT_ATN|IEC_OBIT_SRQ) ; 1
        bst     r24, 7              ; 1 - grab bit 7
        bld     r19, IEC_OPIN_CLOCK ; 1 - store in clock bit
        bst     r24, 6              ; 1 - grab bit 6
        bld     r19, IEC_OPIN_DATA  ; 1 - store in data bit
        lsl     r24                 ; 1 - remove source bits
        lsl     r24                 ; 1

        ;; Wait for 28us from data high
        delay_us 28, -9

        out     _SFR_IO_ADDR(IEC_OUTPUT), r19      ; 1 - output the bit pair

        delay_us 1              ; additional us for loops 2-4

        dec     r20             ; 1 - Decrement bitpair counter
        brne    tdbitloop       ; 2/1 - loop until done

        ;; Wait for 26us from last bitpair
        delay_us 26, -12

        ;; Data high, Clock low
        in      r18, _SFR_IO_ADDR(IEC_OUTPUT)
        andi    r18, ~(IEC_OBIT_DATA|IEC_OBIT_CLOCK|IEC_OBIT_ATN|IEC_OBIT_SRQ)
        ori     r18, IEC_OBIT_CLOCK
        out     _SFR_IO_ADDR(IEC_OUTPUT), r18

        ret


        ;;
        ;; Sends a complete buffer of r22 bytes at r24/r25 using the Turbodisk protocol
        ;;
        .global turbodisk_buffer
turbodisk_buffer:
        ;; Wait until data is low
        sbic    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_DATA
        rjmp    turbodisk_buffer

        ;; All bus lines high
        in      r18, _SFR_IO_ADDR(IEC_OUTPUT)
        andi    r18, ~(IEC_OBIT_DATA|IEC_OBIT_CLOCK|IEC_OBIT_ATN|IEC_OBIT_SRQ)
        out     _SFR_IO_ADDR(IEC_OUTPUT), r18

        movw    r30,r24         ; output pointer

        ;; Wait until data is high
0:      sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_DATA ; 2
        rjmp    0b

        ;; Initial delay of 4 us + move the timing window by 1 us for stability
        delay_us 4+1

        ;; 36 us minus 1 cycle from here to first LDA $DD00 on C64 side ($F822)
tdbyteloop:
        ld      r0, Z+          ; 2 - load byte
        ldi     r20, 4          ; 1 - bitpair counter
        com     r0              ; 1 - invert data byte

        ;; Waste another 12 us
        delay_us 12, -4

tdbitloop2:
        in      r19, _SFR_IO_ADDR(IEC_OUTPUT) ; 1 - read & mask unused IEC port lines
        andi    r19, ~(IEC_OBIT_DATA|IEC_OBIT_CLOCK|IEC_OBIT_ATN|IEC_OBIT_SRQ) ; 1
        bst     r0, 7               ; 1 - grab bit 7
        bld     r19, IEC_OPIN_CLOCK ; 1 - store in clock bit
        bst     r0, 6               ; 1 - grab bit 6
        bld     r19, IEC_OPIN_DATA  ; 1 - store in data bit
        lsl     r0                  ; 1 - remove source bits
        lsl     r0                  ; 1

        ;; Wait another 24 us
        delay_us 24, -9

        out     _SFR_IO_ADDR(IEC_OUTPUT), r19      ; 1 - output the bit pair

        ;; 5 us
        delay_us 5, -3

        dec     r20             ; 1 - Decrement bitpair counter
        brne    tdbitloop2      ; 2/1 - loop until done

        ;; Wait 10 us
        delay_us 10, -3+1

        dec     r22             ; 1 - Decrement byte counter
        brne    tdbyteloop      ; 2/1 - loop until done

        ;; Final delay: 11 us
        delay_us 11

        ;; Data high, Clock low
        in      r18, _SFR_IO_ADDR(IEC_OUTPUT)
        andi    r18, ~(IEC_OBIT_DATA|IEC_OBIT_CLOCK|IEC_OBIT_ATN|IEC_OBIT_SRQ)
        ori     r18, IEC_OBIT_CLOCK
        out     _SFR_IO_ADDR(IEC_OUTPUT), r18

        ret
#endif

#if defined(CONFIG_LOADER_DREAMLOAD) || defined(CONFIG_LOADER_FC3) || defined(CONFIG_LOADER_ULOAD3) || defined(CONFIG_LOADER_ELOAD1) || defined(CONFIG_LOADER_GEOS) || defined(CONFIG_LOADER_HYDPRALOAD) || defined(CONFIG_LOADER_KRILL)
        ;;
        ;; Set bit 0 of r0 on CLOCK and bit 1 on DATA
        ;; A bit value of one means pull down
        ;; After sending these two bits r0 is shifted right two bits
        ;;
        ;; r19 is used as scratch reg here
        ;;
        ;; Takes 10 (or 11 for 22 bit PC MCUs) cycles before OUT (incl. rcall)
        ;; Takes 6 (or 7 for 22 bit PC MCUs) cycles to return after OUT
        ;;
send_bits_to_clk_data:
        ; rcall                  ; 3 or 4
        in   r19, _SFR_IO_ADDR(IEC_OUTPUT) ; 1 - read & mask unused IEC port lines
        andi r19, ~(IEC_OBIT_DATA|IEC_OBIT_CLOCK|IEC_OBIT_ATN|IEC_OBIT_SRQ) ; 1
        bst  r0, 0               ; 1 - take bit 0 (lsb)
        bld  r19, IEC_OPIN_CLOCK ; 1 - for CLOCK line
        bst  r0, 1               ; 1 - take bit 1
        bld  r19, IEC_OPIN_DATA  ; 1 - for DATA line
        out  _SFR_IO_ADDR(IEC_OUTPUT), r19 ; 1 - output the bit pair

        lsr  r0                  ; 1
        lsr  r0                  ; 1 - prepare next two bits

        ret                      ; 4 or 5

        ;;
        ;; Get DATA  => bit 0
        ;; and CLOCK => bit 2 of r24
        ;; Low level means value 0 here
        ;;
        ;; r19 is used as scratch reg here
        ;;
        ;; Takes 4 (or 5 for 22 bit PC MCUs) cycles before IN (incl. rcall)
        ;; Takes 8 (or 9 for 22 bit PC MCUs) cycles to return after IN
        ;;
get_bits_from_clk_data:
        ; rcall                         ; 3 or 4
        in      r19, _SFR_IO_ADDR(IEC_INPUT)  ; 1
        bst     r19, IEC_PIN_DATA       ; 1
        bld     r24, 0                  ; 1
        bst     r19, IEC_PIN_CLOCK      ; 1
        bld     r24, 2                  ; 1
        ret                             ; 4 or 5

#endif

#if defined(CONFIG_LOADER_FC3) || defined(CONFIG_LOADER_ULOAD3) || defined(CONFIG_LOADER_ELOAD1)
        ;;
        ;; Do this kind of handshake:
        ;; set CLOCK low, wait for DATA going low,
        ;; release CLOCK, wait for DATA going high
        ;; returns without waiting if ATN is low
        ;;
        ;; cycles from DATA high to return to caller: 5-11
        ;;
        .global clk_data_handshake
clk_data_handshake:
        sbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_CLOCK
1:
        sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_ATN
        rjmp    2f
        sbic    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_DATA
        rjmp    1b
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_CLOCK
1:
        sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_ATN
        rjmp    2f
        sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_DATA
        rjmp    1b
2:
        ret
#endif

#ifdef CONFIG_LOADER_FC3
        ;;
        ;; Sends four bytes at r24/r25 using the FC3 protocol
        ;;
        .global fastloader_fc3_send_block
fastloader_fc3_send_block:
        cli
        movw    r30,r24         ; Z = output pointer

        ; pull CLOCK low for sync
        sbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_CLOCK ; 1

        ; 12 us between sync and bitpair
        delay_us 12, -14-RCALL_OFFSET

        ldi     r21, 4          ; 1 - byte counter
fc3_byteloop:
        ld      r0, Z+          ; 2 - load byte

        com     r0              ; 1 - negate all bits

        ldi     r20, 4          ; 1 - bitpair counter
fc3_bitloop:
        ; send r0[0,1] to CLOCK and DATA, shift r0 right two times
        ; changes r19
        rcall   send_bits_to_clk_data ; 10 + 6 or 11 + 7

        ; wait 12 us between bitpair
        delay_us 12, -19-RET_OFFSET-RCALL_OFFSET

        dec     r20             ; 1 - decrement bitpair counter
        brne    fc3_bitloop     ; 2/1 - loop until done
fc3_next_byte:
        ; wait 2 us more between two bytes
        ; rcall offset is already accounted for by the previous delay_us
        ; (this was 10 cycles for 8 Mhz, but I think that's 1 cycle off?)
        delay_us 2, -7
        dec     r21             ; 1 - decrement byte counter
        brne    fc3_byteloop    ; 2/1 - loop until done

        ; release CLOCK and DATA
        in      r19, _SFR_IO_ADDR(IEC_OUTPUT) ; read & mask unused IEC port lines
        andi    r19, ~(IEC_OBIT_DATA|IEC_OBIT_CLOCK|IEC_OBIT_ATN|IEC_OBIT_SRQ)
        out     _SFR_IO_ADDR(IEC_OUTPUT), r19 ; release CLOCK and DATA

        sei
        ret

        ;;
        ;; Receive one byte using the FC3 save protocol
        ;;
        .global fc3_get_byte
fc3_get_byte:
        cli

        clr     r24     ; clear data byte

        ; wait a moment before releasing data, otherwise the loop would run
        ; too fast. I confess that this value is guessed.
        delay_us 10

        ; release DATA
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA

        ; wait until CLOCK goes high
1:
        sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK ; 1/2?
        rjmp    1b

        ; 17 us later...
        delay_us 17, -6-RCALL_OFFSET

        ; get bits 5,7 @ 0,2 - changes r19
        rcall   get_bits_from_clk_data  ; 4+8 or 5+9    r24 = .....7.5
        lsl     r24                     ; 1             r24 = ....7.5.

        ; 13 us later...
        delay_us 13, -13-RET_OFFSET-RCALL_OFFSET

        ; get bits 4,6 @ 0,2 - changes r19
        rcall   get_bits_from_clk_data  ; 4+8 or 5+9    r24 = ....7654
        swap    r24                     ; 1             r24 = 7654....
        lsr     r24                     ; 1             r24 = .7654...

        ; 12 us later...
        delay_us 12, -14-RET_OFFSET-RCALL_OFFSET

        ; get bits 1,3 @ 0,2 - changes r19
        rcall   get_bits_from_clk_data  ; 4+8 or 5+9    r24 = .76543.1
        lsl     r24                     ; 1             r24 = 76543.1.

        ; 10 us later...
        delay_us 10, -13-RET_OFFSET-RCALL_OFFSET

        ; get bits 0,2 @ 0,2 - changes r19
        rcall   get_bits_from_clk_data  ; 4+8 or 5+9    r24 = 76543210

        ; Pull DATA down
        sbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA

        sei
        com     r24     ; negate all bits
        clr     r25     ; clear hi-byte of return val
        ret


        ;;
        ;; Send one byte using the old FC3 freezer protocol, PAL version
        ;;
        .global fc3_oldfreeze_pal_send
fc3_oldfreeze_pal_send:
        cli
        mov     r0, r24         ; bitpair subroutine expects data in r0

        ;; clear busy signal
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA

        ;; wait for start signal (clock low->high)
1:      sbic    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK
        rjmp    1b

2:      sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK
        rjmp    2b

        ;; send bits 0+1
        delay_us 14, -10-RCALL_OFFSET
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; send bits 2+3
        delay_us 22-14, -16-RET_OFFSET-RCALL_OFFSET
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; send bits 4+5
        delay_us 30-22, -16-RET_OFFSET-RCALL_OFFSET
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; send bits 6+7
        delay_us 38-30, -16-RET_OFFSET-RCALL_OFFSET
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; hold time before re-enabling busy
        delay_us 46-38, -6-1-RET_OFFSET
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_CLOCK ; 1
        sbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA  ; 1
        delay_us 1

        ;; return inverted ATN state in r24
        in      r24, _SFR_IO_ADDR(IEC_INPUT)
        com     r24
        andi    r24, IEC_BIT_ATN
        sei
        ret


        ;;
        ;; Send one byte using the old FC3 freezer protocol, NTSC version
        ;;
        .global fc3_oldfreeze_ntsc_send
fc3_oldfreeze_ntsc_send:
        cli
        mov     r0, r24         ; bitpair subroutine expects data in r0

        ;; clear busy signal
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA

        ;; wait for start signal (clock low->high)
1:      sbic    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK
        rjmp    1b

2:      sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK
        rjmp    2b

        ;; send bits 0+1
        delay_us 14, -10-RCALL_OFFSET
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; send bits 2+3
        delay_us 24-14, -16-RET_OFFSET-RCALL_OFFSET
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; send bits 4+5
        delay_us 34-24, -16-RET_OFFSET-RCALL_OFFSET
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; send bits 6+7
        delay_us 44-34, -16-RET_OFFSET-RCALL_OFFSET
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; hold time before re-enabling busy
        delay_us 52-44, -6-1-RET_OFFSET
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_CLOCK ; 1
        sbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA  ; 1
        delay_us 1

        ;; return inverted ATN state in r24
        in      r24, _SFR_IO_ADDR(IEC_INPUT)
        com     r24
        andi    r24, IEC_BIT_ATN
        sei
        ret
#endif


#ifdef CONFIG_LOADER_DREAMLOAD
        ;;
        ;; Receive a command (track/sector) using the DreamLoad protocol
        ;;
dreamload_get_command:
        push    r19
        push    r24

        rcall   dreamload_get_byte
        sts     fl_track, r24
        rcall   dreamload_get_byte
        sts     fl_sector, r24

        pop     r24
        pop     r19
        ret

        ;;
        ;; Receive a byte using the DreamLoad protocol
        ;;
        .global dreamload_get_byte
dreamload_get_byte:

        ldi     r18, 4  ; 4 * 2 bits to load
dl_bitloop:
        ; wait until clock goes low
1:
        sbic    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK
        rjmp    1b

        lsl     r24

        ; read data a short time later
        in      r19, _SFR_IO_ADDR(IEC_INPUT)
        bst     r19, IEC_PIN_DATA
        bld     r24, 0

        ; wait until clock goes high
2:
        sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK
        rjmp    2b

        lsl     r24

        ; read data a short time later
        in      r19, _SFR_IO_ADDR(IEC_INPUT)
        bst     r19, IEC_PIN_DATA
        bld     r24, 0

        dec     r18
        brne     dl_bitloop

        com     r24     ; negate all bits
        ret

        ;;
        ;; Receive a command (track/sector) using the old DreamLoad protocol
        ;;
dreamload_get_command_old:
        ; release DATA (which we set for ATN ACK)
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA

        push    r19
        push    r24

        rcall   dreamload_get_byte_old
        sts     fl_track, r24
        rcall   dreamload_get_byte_old
        sts     fl_sector, r24

        pop     r24
        pop     r19
        ret

        ;;
        ;; Receive a byte using the old DreamLoad protocol
        ;;
dreamload_get_byte_old:
        ; 2 nibbles
        ldi     r18, 2
dlgb_nibble:
        swap    r24                     ; 2nd loop: r24 = 7654....
        lsr     r24                     ; 2nd loop: r24 = .7654...

        rcall   wait_atn_low
        ; 1st: get bits 5,7 @ 0,2 / 2nd: get bits 1,3 @ 0,2 - changes r19
        rcall   get_bits_from_clk_data  ; 1st: r24 = .....7.5 / 2nd: .76543.1
        lsl     r24                     ; 1st: r24 = ....7.5. / 2nd: 76543.1.

        rcall   wait_atn_high
        ; 1st: get bits 4,6 @ 0,2 / 2nd: get bits 0,2 @ 0,2 - changes r19
        rcall   get_bits_from_clk_data  ; 1st: r24 = ....7654 / 2nd: 76543210

        dec     r18
        brne    dlgb_nibble

        com     r24     ; negate all bits
        ret

        ;;
        ;; Send the byte in r24 using the DreamLoad protocol
        ;;
        .global dreamload_send_byte
dreamload_send_byte:

        ; inverse all bits
        mov     r0, r24
        com     r0

        ldi     r18, 2          ; loop counter

dsb_bitloop:
        ; send r0[0,1] to CLOCK and DATA, shift r0 right two times
        ; changes r19
        rcall   send_bits_to_clk_data
        rcall   wait_atn_low

        ; send r0[0,1] to CLOCK and DATA, shift r0 right two times
        ; changes r19
        rcall   send_bits_to_clk_data
        rcall   wait_atn_high

        dec     r18             ; decrement bitpair counter
        brne    dsb_bitloop     ; loop until done
        ret
#endif

#if defined CONFIG_LOADER_ULOAD3 || defined CONFIG_LOADER_ELOAD1
        ;;
        ;; Receive a byte using the ULoad Model 3 protocol
        ;;
        .global uload3_get_byte
uload3_get_byte:
        cli
        ldi     r25, 0xff       ; prepare a negative return value
        clr     r24
        rcall   clk_data_handshake
        sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_ATN ;skip ret if ATN is high
        rjmp    uload3_abort                       ;return if ATN is low

        ;; assuming an average of 1.25 us between DATA high and the following instruction
        delay_us 14, -10-4-RCALL_OFFSET

        ;; read bits 7/5
        rcall   get_bits_from_clk_data ;4+8 or 5+9      r24 = _____7_5
        lsl     r24                    ;1               r24 = ____7_5_

        delay_us 10, -13-RET_OFFSET-RCALL_OFFSET

        ;; read bits 6/4
        rcall   get_bits_from_clk_data ;4+8 or 5+9      r24 = ____7654
        swap    r24                    ;1               r24 = 7654____
        lsr     r24                    ;1               r24 = _7654___

        delay_us 14, -14-RET_OFFSET-RCALL_OFFSET

        ;; read bits 3/1
        rcall   get_bits_from_clk_data ;4+8 or 5+9      r24 = _76543_1
        lsl     r24                    ;1               r24 = 76543_1_

        delay_us 10, -13-RET_OFFSET-RCALL_OFFSET

        ;; read bits 2/0
        rcall   get_bits_from_clk_data ;4+8  or 5+9     r24 = 76543210

        delay_us 20, -RET_OFFSET ; wait a bit so the C64 can return the bus to idle state

        clr     r25             ; clear upper byte of return value
        com     r24             ; invert data byte

uload3_abort:
        sei
        ret


        ;;
        ;; Send a byte using the ULoad Model 3 protocol
        ;;
        .global uload3_send_byte
uload3_send_byte:
        cli

        ;; DATA low
        sbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA

        ;; wait for CLOCK low
1:      sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_ATN
        rjmp    2f
        sbic    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK
        rjmp    1b

        ;; DATA high
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA

        ;; wait for CLOCK high - 2 to 7 cycles, assuming 5
1:
        sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_ATN
        rjmp    2f
        sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK
        rjmp    1b

        ;; prepare transmission
        mov     r0, r24         ;1 - move data to output register
        com     r0              ;1 - invert byte
        ldi     r24, 4          ;1 - number of loops
        delay_us 14-8, -8+6+3+RET_OFFSET   ; initial delay before first bit pair

uload3_bitloop:
        delay_us 8, -16-3-RCALL_OFFSET-RET_OFFSET ; delay between bit pairs
        rcall   send_bits_to_clk_data ;10+6 or 11+7
        dec     r24                   ;1 - decrement pair counter
        brne    uload3_bitloop        ;2 - continue loop

        delay_us 10, -9-RET_OFFSET    ; delay before releasing clock/data

        ;; release CLOCK+DATA
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_CLOCK
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA
        delay_us 1              ; safety
2:
        sei
        ret
#endif

#if defined CONFIG_LOADER_EPYXCART || defined CONFIG_LOADER_ULTRABOOT
        ;; send bits 7 and 5 of r0 to clock/data
        ;; masked contents of IEC_OUTPUT expected in r19
        ;; 8 (or 9 for 22 bit PC MCUs) cycles from rcall to out, 4 (or 5) to return
epyx_bitpair:
        ;; rcall - 3 or 4
        bst     r0, 7                      ; 1
        bld     r19, IEC_OPIN_CLOCK        ; 1
        bst     r0, 5                      ; 1
        bld     r19, IEC_OPIN_DATA         ; 1
        out     _SFR_IO_ADDR(IEC_OUTPUT), r19 ; 1
        ret                                ; 4 or 5
#endif

#if defined CONFIG_LOADER_EPYXCART
        ;;
        ;; Send a byte using the Epyx Fastload cartridge protocol
        ;;
        .global epyxcart_send_byte
epyxcart_send_byte:
        ;; DATA and CLOCK high
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_CLOCK
        delay_us 1

        ;; prepare data
        in      r19, _SFR_IO_ADDR(IEC_OUTPUT)
        andi    r19, ~(IEC_OBIT_DATA|IEC_OBIT_CLOCK|IEC_OBIT_ATN|IEC_OBIT_SRQ)

        ;; wait for DATA high or ATN low
1:      sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_ATN
        rjmp    epyxcart_atnabort
        sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_DATA
        rjmp    1b

        mov     r0, r24             ; 1
        delay_us 10, -9-RCALL_OFFSET
        rcall   epyx_bitpair        ; 8+4 or 9+5 - bits 7 and 5

        lsl     r0                  ; 1
        delay_us 10, -13-RET_OFFSET-RCALL_OFFSET
        rcall   epyx_bitpair        ; 8+4 or 9+5 - bits 6 and 4

        swap    r24                 ; 1
        mov     r0, r24             ; 1
        delay_us 10, -14-RET_OFFSET-RCALL_OFFSET
        rcall   epyx_bitpair        ; 8+4 or 9+5 - bits 3 and 1

        lsl     r0                  ; 1
        delay_us 10, -13-RET_OFFSET-RCALL_OFFSET
        rcall   epyx_bitpair        ; 8+4 or 9+5 - bits 2 and 0

        delay_us 20, -RET_OFFSET    ; final delay so the data stays valid long enough

        clr     r24
        ret

epyxcart_atnabort:
        ldi     r24, 1
        ret

#endif

#ifdef CONFIG_LOADER_GEOS
        ;;
        ;; read a byte using the GEOS protocol (common part)
        ;;
geos_get_byte_common:
        clr     r24

        ;; wait until clock is high
1:      sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK
        rjmp    1b

        ;; wait until clock is low
1:      sbic    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK ; 1/2
        rjmp    1b

        ;; delay
        delay_us 15, -2

        ;; get bits 4 and 5
        in      r19, _SFR_IO_ADDR(IEC_INPUT) ; 1
        bst     r19, IEC_PIN_CLOCK         ; 1
        bld     r24, 4-1                   ; 1 - r24 = ....4...
        bst     r19, IEC_PIN_DATA          ; 1
        bld     r24, 5-1                   ; 1 - r24 = ...54...

        ;; delay
        delay_us 14, -5

        ;; get bits 6 and 7
        in      r19, _SFR_IO_ADDR(IEC_INPUT) ; 1
        bst     r19, IEC_PIN_CLOCK         ; 1
        bld     r24, 6-1                   ; 1 - r24 = ..654...
        bst     r19, IEC_PIN_DATA          ; 1
        bld     r24, 7-1                   ; 1 - r24 = .7654...

        ret                                ; 4

        ;;
        ;; read a byte using the GEOS 1MHz (1541) protocol
        ;;
        .global geos_get_byte_1mhz
geos_get_byte_1mhz:
        rcall   geos_get_byte_common   ; 3

        ;; delay
        delay_us 14, -9-4-RET_OFFSET-RCALL_OFFSET

        ;; get bits 3 and 1
        rcall   get_bits_from_clk_data ; 4+8 or 5+9 - r24 = .76543.1
        lsl     r24                    ; 1            r24 = 76543.1.

        ;; delay
        delay_us 16, -9-4-RET_OFFSET-RCALL_OFFSET

        ;; get bits 2 and 0
        rcall   get_bits_from_clk_data ; 4+8 or 5+9 - r24 = 76543210

        ;; post-process received value and return
        delay_us 11, -RET_OFFSET
        com     r24             ; negate all bits
        clr     r25             ; clear high byte of return value
        ret


        ;;
        ;; read a byte using the GEOS 2MHz (1571/81) protocol
        ;;
        .global geos_get_byte_2mhz
geos_get_byte_2mhz:
        rcall   geos_get_byte_common   ; 3

        ;; delay
        delay_05us 19, -9-4-RET_OFFSET-RCALL_OFFSET

        ;; get bits 3 and 1
        rcall   get_bits_from_clk_data ; 4+8 or 5+9 - r24 = .76543.1
        lsl     r24                    ; 1            r24 = 76543.1.

        ;; delay
        delay_05us 22, -9-4-RET_OFFSET-RCALL_OFFSET

        ;; get bits 2 and 0
        rcall   get_bits_from_clk_data ; 4+8 or 5+9 - r24 = 76543210

        ;;  post process received value and return
        delay_us 11-RET_OFFSET
        com     r24             ; negate all bits
        clr     r25             ; clear high byte of return value
        ret


        ;;
        ;; common part of all geos_send_byte implementations
        ;;  returns 7 (or 8 for 22 bit PC MCUs) cycles after clock low
        ;;
geos_send_byte_common:
        ;; CLOCK/DATA high
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_CLOCK
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA
        delay_us 1

        ;; wait until CLOCK is low
1:      sbic    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK
        rjmp    1b

        ;; preserve non-IEC lines on IEC_OUTPUT port
        in      r19, _SFR_IO_ADDR(IEC_OUTPUT) ; 1
        andi    r19, ~(IEC_OBIT_DATA|IEC_OBIT_CLOCK|IEC_OBIT_ATN|IEC_OBIT_SRQ) ; 1
        mov     r0, r19             ; 1
        ret                         ; 4 or 5

        ;;
        ;; send a byte using the GEOS 1MHz protocol
        ;; called with byte in r24, return value undefined
        ;;
        .global geos_send_byte_1mhz
geos_send_byte_1mhz:
        rcall   geos_send_byte_common ; 7 or 8

        ;; prepare bits 3+1
        bst     r24, 3              ; 1 - read bit 3
        bld     r19, IEC_OPIN_CLOCK ; 1 - store in clock bit
        bst     r24, 1              ; 1 - read bit 1
        bld     r19, IEC_OPIN_DATA  ; 1 - store in data bit

        ;; delay (1MHz speeder)
        delay_us 18, -14-RET_OFFSET
        rjmp    geos_send_byte_tail   ; 2


        ;;
        ;; send a byte using the GEOS 2MHz protocol
        ;; called with byte in r24, return value undefined
        ;;
        .global geos_send_byte_2mhz
geos_send_byte_2mhz:
        rcall   geos_send_byte_common ; 7 or 8

        ;; prepare bits 3+1
        bst     r24, 3              ; 1 - read bit 3
        bld     r19, IEC_OPIN_CLOCK ; 1 - store in clock bit
        bst     r24, 1              ; 1 - read bit 1
        bld     r19, IEC_OPIN_DATA  ; 1 - store in data bit

        ;; delay (2MHz speeder)
1:      delay_05us 18, -12-RET_OFFSET

geos_send_byte_tail:
        ;; send to bus
        out     _SFR_IO_ADDR(IEC_OUTPUT), r19 ; 1 - send to bus

        ;; prepare bits 2+0
        mov     r19, r0             ; 1
        bst     r24, 2              ; 1 - read bit 2
        bld     r19, IEC_OPIN_CLOCK ; 1 - store in clock bit
        bst     r24, 0              ; 1 - read bit 0
        bld     r19, IEC_OPIN_DATA  ; 1 - store in data bit

        ;; delay
        delay_us 10, -6

        ;; send to bus
        out     _SFR_IO_ADDR(IEC_OUTPUT), r19 ; 1

        ;; prepare bits 4+5
        com     r24                 ; 1 - remaining bits are sent with high=1
        mov     r19, r0             ; 1
        bst     r24, 4              ; 1 - read bit 4
        bld     r19, IEC_OPIN_CLOCK ; 1 - store in clock bit
        bst     r24, 5              ; 1 - read bit 5
        bld     r19, IEC_OPIN_DATA  ; 1 - store in data bit

        ;; delay
        delay_us 11, -7

        ;; send to bus
        out     _SFR_IO_ADDR(IEC_OUTPUT), r19 ; 1

        ;; prepare bits 6+7
        mov     r19, r0             ; 1
        bst     r24, 6              ; 1 - read bit 6
        bld     r19, IEC_OPIN_CLOCK ; 1 - store in clock bit
        bst     r24, 7              ; 1 - read bit 7
        bld     r19, IEC_OPIN_DATA  ; 1 - store in data bit

        ;; delay
        delay_us 12, -6

        ;; send to bus
        out     _SFR_IO_ADDR(IEC_OUTPUT), r19 ; 1

        ;; final delay
        delay_us 22

        ret


        ;;
        ;; send a byte using the 2MHz 1581 Configure 2.1 GEOS protocol
        ;; called with byte in r24, return value undefined
        ;;
        .global geos_send_byte_1581_21
geos_send_byte_1581_21:
        com     r24                   ; invert so the bits are sent with high=1
        rcall   geos_send_byte_common ; 7 or 8
        mov     r0, r24               ; 1 - move data to target register

        ;; delay
        delay_us 7, -18-RET_OFFSET-RCALL_OFFSET

        ;; send bits 0+1
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; delay
        delay_us 7, -16-RET_OFFSET-RCALL_OFFSET

        ;; send bits 2+3
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; delay
        delay_us 10, -16-RET_OFFSET-RCALL_OFFSET

        ;; send bits 4+5
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; delay
        delay_us 9, -16-RET_OFFSET-RCALL_OFFSET

        ;; send bits 6+7
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; final delay
        delay_us 12, -RET_OFFSET

        ret

#endif

#ifdef CONFIG_LOADER_WHEELS
        ;;
        ;; send a byte using the Wheels protocol
        ;; called with byte in r24, return value undefined
        ;;
        .global wheels_send_byte_1mhz
wheels_send_byte_1mhz:
        rcall   geos_send_byte_common ; 7 or 8

        rcall   wheels_nibble       ; 3 - send lower nibble
        swap    r24                 ; 1 - swap nibbles

        ;; wheels_nibble accounts for the rcall offset itself
        delay_us 14-9, 15-14-RET_OFFSET
        rcall   wheels_nibble       ; 3 - send upper nibble

        ;; final delay
        delay_us 22, -RET_OFFSET
        ret

wheels_nibble:
        ;; prepare bits 3+1 (7+5)
        mov     r19, r0             ; 1
        bst     r24, 3              ; 1 - read bit 3
        bld     r19, IEC_OPIN_CLOCK ; 1 - store in clock bit
        bst     r24, 1              ; 1 - read bit 1
        bld     r19, IEC_OPIN_DATA  ; 1 - store in data bit

        ;; delay
        delay_us 9, -15-RET_OFFSET-RCALL_OFFSET

        ;; send to bus
        out     _SFR_IO_ADDR(IEC_OUTPUT), r19 ; 1 - send to bus

        ;; prepare bits 2+0 (6+4)
        mov     r19, r0             ; 1
        bst     r24, 2              ; 1 - read bit 2
        bld     r19, IEC_OPIN_CLOCK ; 1 - store in clock bit
        bst     r24, 0              ; 1 - read bit 0
        bld     r19, IEC_OPIN_DATA  ; 1 - store in data bit

        ;; delay
        delay_us 14, -6

        ;; send to bus
        out     _SFR_IO_ADDR(IEC_OUTPUT), r19 ; 1 - send to bus
        ret                                ; 4 or 5


        ;;
        ;; read a byte using the Wheels protocol
        ;;
        .global wheels_get_byte_1mhz
wheels_get_byte_1mhz:
        clr     r24

        ;; wait until clock is high
1:      sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK
        rjmp    1b

        ;; wait until clock is low
1:      sbic    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK ; 1/2
        rjmp    1b

        ;; delay
        delay_us 16, -5-RCALL_OFFSET

        ;; read bits 7/5
        rcall   get_bits_from_clk_data ; 4+8 or 5+9     r24 = _____7_5
        lsl     r24                    ; 1              r24 = ____7_5_

        delay_us 10, -13-RET_OFFSET-RCALL_OFFSET

        ;; read bits 6/4
        rcall   get_bits_from_clk_data ; 4+8 or 5+9     r24 = ____7654
        swap    r24                    ; 1              r24 = 7654____
        lsr     r24                    ; 1              r24 = _7654___

        delay_us 15, -14-RET_OFFSET-RCALL_OFFSET

        ;; read bits 3/1
        rcall   get_bits_from_clk_data ; 4+8 or 5+9     r24 = _76543_1
        lsl     r24                    ; 1              r24 = 76543_1_

        delay_us 13, -13-RET_OFFSET-RCALL_OFFSET

        ;; read bits 2/0
        rcall   get_bits_from_clk_data ; 4+8  or 5+9    r24 = 76543210

        delay_us 20, -RET_OFFSET

        clr     r25             ; clear upper byte of return value
        com     r24             ; invert data byte

        ret

        ;;
        ;; read a byte using the Wheels 4.4 1MHz protocol
        ;;
        .global wheels44_get_byte_1mhz
wheels44_get_byte_1mhz:
        clr     r24

        ;; wait until clock is high
1:      sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK
        rjmp    1b

        ;; wait until clock is low
1:      sbic    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK ; 1/2
        rjmp    1b

        ;; delay
        delay_us 17, -5-RCALL_OFFSET

        ;; read bits 7/5
        rcall   get_bits_from_clk_data ; 4+8 or 5+9     r24 = _____7_5
        lsl     r24                    ; 1              r24 = ____7_5_

        delay_us 11, -13-RET_OFFSET-RCALL_OFFSET

        ;; read bits 6/4
        rcall   get_bits_from_clk_data ; 4+8 or 5+9     r24 = ____7654
        swap    r24                    ; 1              r24 = 7654____
        lsr     r24                    ; 1              r24 = _7654___

        delay_us 17, -14-RET_OFFSET-RCALL_OFFSET

        ;; read bits 3/1
        rcall   get_bits_from_clk_data ; 4+8 or 5+9     r24 = _76543_1
        lsl     r24                    ; 1              r24 = 76543_1_

        delay_us 16, -13-RET_OFFSET-RCALL_OFFSET

        ;; read bits 2/0
        rcall   get_bits_from_clk_data ; 4+8 or 5+9     r24 = 76543210

        delay_us 20, -RET_OFFSET

        clr     r25             ; clear upper byte of return value
        com     r24             ; invert data byte

        ret

        ;;
        ;; read a byte using the Wheels 4.4 2MHz protocol
        ;;
        .global wheels44_get_byte_2mhz
wheels44_get_byte_2mhz:
        clr     r24

        ;; wait until clock is high
1:      sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK
        rjmp    1b

        ;; wait until clock is low
1:      sbic    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK ; 1/2
        rjmp    1b

        ;; delay
        delay_us 15, -2

        ;; get bits 0 and 1
        in      r19, _SFR_IO_ADDR(IEC_INPUT) ; 1
        bst     r19, IEC_PIN_CLOCK         ; 1
        bld     r24, 0                     ; 1 - r24 = .......0
        bst     r19, IEC_PIN_DATA          ; 1
        bld     r24, 1                     ; 1 - r24 = ......10

        ;; delay
        delay_us 11, -5

        ;; get bits 2 and 3
        in      r19, _SFR_IO_ADDR(IEC_INPUT) ; 1
        bst     r19, IEC_PIN_CLOCK         ; 1
        bld     r24, 2                     ; 1 - r24 = .....210
        bst     r19, IEC_PIN_DATA          ; 1
        bld     r24, 3                     ; 1 - r24 = ....3210

        ;; delay
        delay_us 11, -5

        ;; get bits 4 and 5
        in      r19, _SFR_IO_ADDR(IEC_INPUT) ; 1
        bst     r19, IEC_PIN_CLOCK         ; 1
        bld     r24, 4                     ; 1 - r24 = ...43210
        bst     r19, IEC_PIN_DATA          ; 1
        bld     r24, 5                     ; 1 - r24 = ..543210

        ;; delay
        delay_us 11, -5

        ;; get bits 6 and 7
        in      r19, _SFR_IO_ADDR(IEC_INPUT) ; 1
        bst     r19, IEC_PIN_CLOCK         ; 1
        bld     r24, 6                     ; 1 - r24 = .6543210
        bst     r19, IEC_PIN_DATA          ; 1
        bld     r24, 7                     ; 1 - r24 = 76543210

        ;; safety delay
        delay_us 12

        ;; post process received value and return
        com     r24                  ; negate all bits
        clr     r25                  ; clear high byte of return value
        ret


        ;;
        ;; send a byte using the Wheels 4.4 2MHz protocol
        ;; called with byte in r24, return value undefined
        ;;
        .global wheels44_send_byte_2mhz
wheels44_send_byte_2mhz:
        com     r24                   ; invert so the bits are sent with high=1
        rcall   geos_send_byte_common ; 7 or 8
        mov     r0, r24               ; 1 - move data to target register

        ;; delay
        delay_us 7, -18-RET_OFFSET-RCALL_OFFSET

        ;; send bits 0+1
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; delay
        delay_us 8, -16-RET_OFFSET-RCALL_OFFSET

        ;; send bits 2+3
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; delay
        delay_us 11, -16-RET_OFFSET-RCALL_OFFSET

        ;; send bits 4+5
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; delay
        delay_us 11, -16-RET_OFFSET-RCALL_OFFSET

        ;; send bits 6+7
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; final delay
        delay_us 14, -RET_OFFSET

        ret

#endif

#ifdef CONFIG_LOADER_AR6
        ;;
        ;; send a byte using the AR6-1581 protocol
        ;; called with byte in r24, no return value
        ;;
        .global ar6_1581_send_byte
ar6_1581_send_byte:
        cli

        ;; set up data byte for transmission
        com     r24
        mov     r0, r24

        ;; clock high
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_CLOCK

        ;; wait until data is high
1:      sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_DATA
        rjmp    1b

        ;; delay
        delay_us 5, -10-RCALL_OFFSET

        ;; send bits 0+1
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; delay
        delay_us 8, -16-RET_OFFSET-RCALL_OFFSET

        ;; send bits 2+3
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; delay
        delay_us 8, -16-RET_OFFSET-RCALL_OFFSET

        ;; send bits 4+5
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; delay
        delay_us 8, -16-RET_OFFSET-RCALL_OFFSET

        ;; send bits 6+7
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; delay
        delay_05us 17, -6-2-RET_OFFSET

        ;; set clock low, data high
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA  ; 1
        sbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_CLOCK ; 1

        sei
        ret

        ;;
        ;; receive a byte using the AR6-1581-PAL protocol
        ;; returns byte in r24
        ;;
        .global ar6_1581p_get_byte
ar6_1581p_get_byte:
        cli

        clr     r24

        ;; clock high
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_CLOCK

        ;; wait until data is low
1:      sbic    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_DATA
        rjmp    1b

        ;; wait until data is high
1:      sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_DATA
        rjmp    1b

        ;; delay
        delay_us 12, -4-RCALL_OFFSET

        ;; receive bits 7+5
        rcall   get_bits_from_clk_data ; 4+8 or 5+9 - r24 = .....7.5
        lsl     r24                    ; 1          - r24 = ....7.5.

        ;; delay
        delay_us 10, -9-4-RET_OFFSET-RCALL_OFFSET

        ;; receive bits 6+4
        rcall   get_bits_from_clk_data ; 4+8 or 5+9 - r24 = ....7654
        swap    r24                    ; 1          - r24 = 7654....
        lsr     r24                    ; 1          - r24 = .7654...

        ;; delay
        delay_us 16, -10-4-RET_OFFSET-RCALL_OFFSET

        ;; receive bits 3+1
        rcall   get_bits_from_clk_data ; 4+8 or 5+9 - r24 = .76543.1
        lsl     r24                    ; 1          - r24 = 76543.1.

        ;; delay
        delay_us 10, -9-4-RET_OFFSET-RCALL_OFFSET

        ;; receive bits 2+0
        rcall   get_bits_from_clk_data ; 4+8 or 5+9 - r24 = 76543210

        ;; delay
        delay_us 5, -8-1-RET_OFFSET

        ;; set clock low
        sbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_CLOCK

        ;; post-processing
        sei
        com     r24
        clr     r25
        ret
#endif

#ifdef PARALLEL_ENABLED
        ;; ====================================================================
        ;;  Parallel port
        ;; ====================================================================

        ;; uint8_t parallel_read(void)
        .global parallel_read
parallel_read:
        in      r24, _SFR_IO_ADDR(PARALLEL_PPIN)
        ret

        ;; void parallel_write(uint8_t value)
        .global parallel_write
parallel_write:
        out     _SFR_IO_ADDR(PARALLEL_PDDR),  r1   ; set all lines to input
        out     _SFR_IO_ADDR(PARALLEL_PPORT), r24  ; enable pullups on 1-bits
        com     r24                                ; invert byte
        out     _SFR_IO_ADDR(PARALLEL_PDDR), r24   ; set 0-bits to output to simulate open collector
        delay_us 1
        ret

        ;; void parallel_set_dir(parallel_dir_t direction)
        .global parallel_set_dir
parallel_set_dir:
        tst     r24                               ; check if input is selected
        brne    1f                                ; do nothing if not
        out     _SFR_IO_ADDR(PARALLEL_PDDR), r1   ; set all lines to input
        com     r24                               ; set r24=0xff
        out     _SFR_IO_ADDR(PARALLEL_PPORT), r24 ; enable all pullups
1:      ret

        ;; void parallel_send_handshake(void)
        .global parallel_send_handshake
parallel_send_handshake:
        cbi     _SFR_IO_ADDR(PARALLEL_HPORT), PARALLEL_HSK_OUT_BIT ; prepare 0 in PORT register
        sbi     _SFR_IO_ADDR(PARALLEL_HDDR), PARALLEL_HSK_OUT_BIT  ; set pin to output
        delay_us 2                                                 ; delay
        cbi     _SFR_IO_ADDR(PARALLEL_HDDR), PARALLEL_HSK_OUT_BIT  ; set pin to input
        sbi     _SFR_IO_ADDR(PARALLEL_HPORT), PARALLEL_HSK_OUT_BIT ; enable pullup
        ret

#endif

#ifdef CONFIG_LOADER_N0SDOS
        ;; ====================================================================
        ;;  N0stalgia loaders
        ;; ====================================================================

        ;; void n0sdos_send_byte(uint8_t byte)
        .global n0sdos_send_byte
n0sdos_send_byte:
        cli

        ;; set up data byte for transmission
        mov     r0, r24

        ;; clock and data high
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_CLOCK
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA

        ;; wait until clock is high
1:      sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_CLOCK
        rjmp    1b

        ;; delay
        delay_us 9, -10-RCALL_OFFSET

        ;; send bits 0+1
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; delay
        delay_us 8, -16-RET_OFFSET-RCALL_OFFSET

        ;; send bits 2+3
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; delay
        delay_us 8, -16-RET_OFFSET-RCALL_OFFSET

        ;; send bits 4+5
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; delay
        delay_us 8, -16-RET_OFFSET-RCALL_OFFSET

        ;; send bits 6+7
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; delay
        delay_us 5, -6-2-RET_OFFSET

        ;; set clock high, data low
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_CLOCK ; 1
        sbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA  ; 1

        delay_us 6

        sei
        ret

#endif

#ifdef CONFIG_LOADER_ULTRABOOT
        ;;
        ;; send a byte using the Ultraboot protocol
        ;; called with byte in r24, returns status (host set DATA) in r24
        ;;
        ;; Ultraload uses the same bit order as Epyx but with a slightly
        ;; different timing.
        .global ultraboot_send_byte
ultraboot_send_byte:

        cli

        ;; prepare data
        in      r19, _SFR_IO_ADDR(IEC_OUTPUT)
        andi    r19, ~(IEC_OBIT_DATA|IEC_OBIT_CLOCK|IEC_OBIT_ATN|IEC_OBIT_SRQ)

        ;; wait for DATA high
1:      sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_DATA
        rjmp    1b

        ;; 0 us: set DATA
        sbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA         ; 2

        ;; 15 us: release DATA
        delay_us 15, -2
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA         ; 2

        mov     r0, r24                                         ; 1

        ;; 19 us: first bitpair
        delay_us 4, -11-RCALL_OFFSET
        rcall   epyx_bitpair            ; 8+4 or 9+5 - bits 7 and 5

        ;; 27 us: second bitpair
        lsl     r0                                              ; 1
        delay_us 8, -13-RET_OFFSET-RCALL_OFFSET
        rcall   epyx_bitpair            ; 8+4 or 9+5 - bits 6 and 4

        ;; 35 us: third bitpair
        swap    r24                                             ; 1
        mov     r0, r24                                         ; 1
        delay_us 8, -14-RET_OFFSET-RCALL_OFFSET
        rcall   epyx_bitpair            ; 8+4 or 9+5 - bits 3 and 1

        ;; 43 us: last bitpair
        lsl     r0                                              ; 1
        delay_us 8, -13-RET_OFFSET-RCALL_OFFSET
        rcall   epyx_bitpair            ; 8+4 or 9+5 - bits 2 and 0

        ;; 51 us: release DATA
        delay_us 8, -5-RET_OFFSET
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_DATA         ; 2

        ;; 56 us: the host should have set DATA now
        delay_us 5, -1
        in      r24, _SFR_IO_ADDR(IEC_INPUT)
        andi    r24, IEC_BIT_DATA

        sei
        ret

#endif

#ifdef CONFIG_LOADER_HYPRALOAD
        ;;
        ;; send a byte using the Hypra-Load protocol (either unsing
        ;; the original or the 2.1 protocol, depending on entry point)
        ;;
        ;; called with byte in r24, always returns zero
        ;;
        ;; r18, r19 scratch (r19 also used by send_bits_to_clk_data)
        ;; r20      bitmask for request line
        ;; r21      bitmask for "busy"
        .global hypraload10_send_byte
hypraload10_send_byte:
        ldi     r20, IEC_BIT_ATN
        ldi     r21, ~IEC_OBIT_DATA
        rjmp    hl_send_byte_common

        .global hypraload21_send_byte
hypraload21_send_byte:
        ldi     r20, IEC_BIT_DATA
        ldi     r21, ~IEC_OBIT_CLOCK

hl_send_byte_common:
        cli

        mov     r0, r24

        ;; wait for request line low (1.0: ATN / 2.1: DATA)
1:      in      r18, _SFR_IO_ADDR(IEC_INPUT)
        and     r18, r20
        brne    1b

        ;; release "busy" line (1.0: DATA / 2.1: CLK)
        in      r19, _SFR_IO_ADDR(IEC_OUTPUT)
        and     r19, r21
        out     _SFR_IO_ADDR(IEC_OUTPUT), r19
        com     r21     ; prepare bitmask for *setting* "busy" again, later

        ;; wait for request line high
1:      in      r18, _SFR_IO_ADDR(IEC_INPUT)
        and     r18, r20
        breq    1b                      ; 3 after request line high

        ;; delay
        delay_us 30, -13-RCALL_OFFSET

        ;; send bits 0+1
        rcall   send_bits_to_clk_data   ; 10+6 or 11+7

        ;; delay
        delay_us 25, -16-RET_OFFSET-RCALL_OFFSET

        ;; send bits 2+3
        rcall   send_bits_to_clk_data   ; 10+6 or 11+7

        ;; delay
        delay_us 25, -16-RET_OFFSET-RCALL_OFFSET

        ;; send bits 4+5
        rcall   send_bits_to_clk_data   ; 10+6 or 11+7

        ;; delay
        delay_us 25, -16-RET_OFFSET-RCALL_OFFSET

        ;; send bits 6+7
        rcall   send_bits_to_clk_data   ; 10+6 or 11+7

        ;; delay
        delay_us 25, -8-RET_OFFSET

        ;; busy
        in      r19, _SFR_IO_ADDR(IEC_OUTPUT)
        andi    r19, ~IEC_BIT_DATA      ; mask out DATA in case it's 2.1
        or      r19, r21
        out     _SFR_IO_ADDR(IEC_OUTPUT), r19

        sei
        clr     r24

        ret

#endif

#ifdef CONFIG_LOADER_KRILL
        ;;
        ;; send a byte using Krill's loader's resend protocol
        ;; called with byte in r24, always returns zero
        ;;

        ;; uint8_t krill_send_byte_resend(uint8_t byte)
        .global krill_send_byte_resend
krill_send_byte_resend:
        ;; called from an ATOMIC_BLOCK, so no need to inhibit interrupts

        ;; set up data byte for transmission
        com     r24
1:
        mov     r0, r24

        rcall   wait_atn_low
        rcall   wait_atn_high

        ;; send bits 0+1
        delay_us 10, -16-RET_OFFSET-RCALL_OFFSET
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; send bits 2+3
        delay_us 18-10, -16-RET_OFFSET-RCALL_OFFSET
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; send bits 4+5
        delay_us 26-18, -16-RET_OFFSET-RCALL_OFFSET
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        ;; send bits 6+7
        delay_us 34-26, -16-RET_OFFSET-RCALL_OFFSET
        rcall   send_bits_to_clk_data ; 10+6 or 11+7

        delay_us 42-34, -7-RET_OFFSET
        cbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_CLOCK ; 2

        delay_us 50-42, -2

        ;; return if the host has set ATN in time
        sbis    _SFR_IO_ADDR(IEC_INPUT), IEC_PIN_ATN
        rjmp    2f

        ;; otherwise set clock to signal that we are going to send again
        sbi     _SFR_IO_ADDR(IEC_OUTPUT), IEC_OPIN_CLOCK
        rjmp    1b

2:
        clr     r24
        ret

#endif

        .end
